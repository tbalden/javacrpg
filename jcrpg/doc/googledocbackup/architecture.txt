Java Classic RPG - Architectural Overview


0th Level Physical System Plan

JCRPG application consists of the following main units:

   1. J3DCore - The core part of the game containing game state data and graphics / audio related engine classes
   2. Engine - Responsible for counting the world's time passing in a separated thread independently of the 3D engine/graphics
   3. AudioServer - Runs with a separate thread, playing music/sounds on different channels
   4. GameStateContainer - Savable/Loadable container object for storing all the dynamic game session data. Sub-elements:
         1. World - provider of the abstract static elements of the surrounding world: geographies, buildings, climate elements, flora
               1. EconomyContainer - class for economy related mechanisms like updating populations
         2. Ecology - provider of the abstract dynamic elements of the surrounding world: Moving AI like animals, humanoids, NPCs
         3. GameLogic - game event organizing unit, helper for encounter phases, interaction.
               1. EncounterLogic - logic to organize details of an encounter - player or entity involved.
   5. J3DStandingEngine - Responsible for rendering static contents like geography, buildings and such
   6. J3DMovingEngine - Responsible for rendering moving units



Build up of abstract static contents

The static World is tile based built of 6 sided cubes (n/s/w/e/top/bottom) with the following important abstract representation classes:

SideSubType (extended by different types like Swimming, Climbing, GroundSubType) -> Side -> Cube (consisting of 6 Side[] arrays)

Cube: each Cube is consisting of 6 Side[] arrays that describe the different merged elements on each side. All the Cubes generated in the game have unique coordinates describing world position with 3 coordinates (X East - West,Y Down - Up, Z South - North direction). The main rendered of the Cube object instances is called World. World is building up a cube at a given coordinate X,Y,Z with the help of its contained subclasses. Subclasses are Geography instances (e.g. Mountain,Plain,Forest,Cave), FloraContainer (rendering flora with the help of FloraGenerator) and Waters (which are specialized classes of Geography class, e.g. Ocean, River). Each of these sub elements of World will return a Cube if they cover the given coordinate and these Cubes are merged into one single Cube and returned by World. (This function of World is mainly used by J3DStaticEngine's render part through RenderedArea helper class.)

World - rendering process


Mechanisms of the dynamic contents

Ecology - turn process

Ecology, the engine of moving life
EntityInstance, EntityDescription, EntityMemberInstance, EntityMemberDescription, liveTurn, EntityFragment

Ecology contains the list of EntityInstances and is the class that calculates possible encounters between living instances and triggers liveTurn events per turn for the instances in shuffled order.

EntityInstance is a grouping instance that has some common properties determined by its contained type class called EntityDescription. A group can have fix members (e.g. an NPC), it's stored in a set of EntityMemberInstances. An entity member instance is containing a type class to called EntityMemberDescription. These descriptions contain information about default attributes, levels, points, skills, behavior patterns. The instances contain relations and varying versions of the attributes, skills, owned economics etc..

Every turn the ecology runs a liveTurn for it's contained living instances in a turn-by-turn shuffled order. AI Instances can decide what to do in the turn and can encounter other instances and the player too. Among them the player (PartyInstance) is doing it liveTurn too, and if surrounding instances are near enough and the skills of player make it possible, the UI part of the game is popped up for the player to interact with those encountered.

EntityFragment

For specific tasks and goals EntityInstances will split themselves up into fragments. A base fragment is created upon EntityInstance setup, then later the Instance can create other smaller fragments of the base fragment or unite two fragments. For example a town's fighter group instance can decide to go for a trip around waging war against the enemies of the town. This EntityFragment is very low on contained data, restricted to size and RoamingBoundaries plus a special followingEntityMembers list that contains those NPCs that decided to follow the fragment for a while. This all serves as a small physical memory consuming solution for different multi placed operations of an EntityInstance.


EntityInstance Relation System

EntityRelations, added to EntityInstance class, serves as relation quality storage for inter-entityInstance relations.


Economy

Economic, the base class
Population, Residence, EconomicGround, WorkGround, AbstractInfrastructure

It is the base class of Economic places, extension of Place. Economics are in general handled by the EconomicContainer class which in it's highest level containment stores Populations (extension of Economic) and so Called non-places Towns. An Economic may have one owner EntityInstance and a Geography as soil.

Populations are to be considered districts, and are restricted to take physical form in a geography block sized area. Populations are consisting of Residences, EconomicGrounds and WorkGrounds. Each population have one AbstractInfrastructure extension that generates the Population's structure and layout.

Economy update turn

It happens every X turns (let's say it will be happening daily in a stable version), and if a given population zone's inhabitant number has changed so much (or such an update-triggering event occurres) it recalculates a whole population infrastructure regenerating the population's physical form. (Different size levels are generated in a way that the structure of the previous size feels consistent with the new town structure.) Dynamic districts like in a "building your city" strategy game. The population's structure calculus is depending on extension of the class AbstractInfrastructure. The "reconstruction" turn means a total reload of the player 3D surroundings, a little tool icon showing that there's an economy update turn going on. Upon finishing, the player's position is recalculated to make sure that the player is still on the surface of the world.

EconomyContainer's doEconomyUpdate is going through all of the Populations and calls it's update function. It will use its AbstractInfrastructure to do the real update. DefaultInfrastructure  is an example for implementation of Abstract. In this one a size drive build program is used to construct the structure of the city. Positioning of the residence and such are based on a shuffle positions algorithm, using HashUtils to randomize positions.


Generators

World and Ecology at time of a new game

Encounters

EncounterInfo
EncounterUnit, EncounterUnitData, Lineup, Topology
Ecology takes living fragments of the 'beings' list in a shuffled order and calculates boundary intersections summarizing close intersections into so called EncounterInfo data classes that contains meeting EntityInstance fragments' group ids and fragments PersistentMemberInstances as subUnits. Both EntityFragment and Pers.MemberInst. classes extends EncounterUnit interface through which common information like name, size, groupIds, group sizes can be extracted for the GameLogic.

EncounterInfo creates and maintains a list of the EncounterUnit packaging them into EncoutnerUnitData which adds special encounter related strategic data for them like current size and topology/lineup line. EncounterUnitLineup class is a single priority based container class for the encounter phase that determines order of Enc.UnitData helping e.g. the 3D visualization. TurnActUnitTopology contains two Lineups, one friendly and one enemy lineup. Both of these (encounter lineup and turn act topology) are converted into a PlacementMatrix (containing ahead and back matrix) by EncounterInfo for the GameLogic to use for placing 3D units on the tiles. This is done upon initializing the given phase (encounter or turnAct).

Encounter Screenplays - EncounterLogic based upon player's (done on UI) and computer choices (done in EntityMemberInstance) generates a chain of events happening in Encounter Phase Round or Turn Act Phase Turn. It is played by EncounterLogic step by step with the help of the plan in a State object also created by EncounterLogic while calculating the happenings. To make 3D updates work after each step is started playing the control is given back to 3D engine, but in J3DCore.simpleUpdate there is a callback check to EncounterLogic if the next step can be played. E.g. a pause in 3D scenario is going on, every simpleUpdate calls the check, and if enough time has passed the next screenplay step will be activated e.g. moving units.
